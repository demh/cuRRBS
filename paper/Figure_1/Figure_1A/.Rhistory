# numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=4, name = "RdYlBu")[4]
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=4, name = "YlGn ")[1]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=4, name = "YlGn ")[2]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=4, name = "YlGn ")[3]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=4, name = "YlGn ")[4]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=4, name = "YlGn ")[1],brewer.pal(n=4, name = "YlGn")[2],brewer.pal(n=4, name = "YlGn")[3],brewer.pal(n=4, name = "YlGn")[4])
)
dev.off()
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=4, name = "YlGn")[1]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=4, name = "YlGn")[2]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=4, name = "YlGn")[3]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=4, name = "YlGn")[4]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=4, name = "YlGn")[1],brewer.pal(n=4, name = "YlGn")[2],brewer.pal(n=4, name = "YlGn")[3],brewer.pal(n=4, name = "YlGn")[4])
)
dev.off()
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=4, name = "YlGn")[1],brewer.pal(n=4, name = "YlGn")[2],brewer.pal(n=4, name = "YlGn")[3],brewer.pal(n=4, name = "YlGn")[4])
)
dev.off()
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=5, name = "YlGn")[2],brewer.pal(n=5, name = "YlGn")[3],brewer.pal(n=5, name = "YlGn")[4],brewer.pal(n=5, name = "YlGn")[5])
)
dev.off()
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "Greens")[2]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "Greens")[3]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "Greens")[4]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "Greens")[5]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=5, name = "Greens")[2],brewer.pal(n=5, name = "Greens")[3],brewer.pal(n=5, name = "Greens")[4],brewer.pal(n=5, name = "Greens")[5])
)
dev.off()
numberAT<-sapply(names, GC, exact=TRUE)
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5]
tipColour<-numberAT
####### plotting phylogeny #######
pdf(file = "Phylogeny_restriction_motifs_2.pdf",width = 20,height = 20,paper = "special")
plot.phylo(phylo, type="r",tip.color =tipColour,
cex=2,font=2,edge.width=c(4),no.margin=T)
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=5, name = "YlGn")[2],brewer.pal(n=5, name = "YlGn")[3],brewer.pal(n=5, name = "YlGn")[4],brewer.pal(n=5, name = "YlGn")[5])
)
dev.off()
numberAT<-sapply(test_motifs, GC, exact=TRUE)
# numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=4, name = "RdYlBu")[1]
# numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=4, name = "RdYlBu")[2]
# numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=4, name = "RdYlBu")[3]
# numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=4, name = "RdYlBu")[4]
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2]
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3]
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4]
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5]
###### plot function ######
pdf(file = "PCA_restriction_motifs_2.pdf",width = 10,height = 10,paper = "special")
symbols(x=data_to_plot, circles=width_to_plot, xlim=c(-5,3),ylim = c(-3,3),
inches=1/5,ann=F, bg=numberAT, fg=NULL)
title(xlab="First component", ylab="Second component")
legend("topleft",legend = c("0-25% GC content", "25-50% GC content","50-75% GC content","75-100% GC content"), fill = c(
brewer.pal(n=5, name = "YlGn")[2],brewer.pal(n=5, name = "YlGn")[3],brewer.pal(n=5, name = "YlGn")[4],brewer.pal(n=5, name = "YlGn")[5])
)
dev.off()
source('~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Supp_Figure_1/Supp_Figure_1A_B/enzyme_motifs.R')
motifs <- read.table("recognition_sites_enzymes.csv", header = F, sep = ",");
View(motifs)
###########################################################################################
#########                                                                         #########
#########                     Daniel Elias Martin Herranz                         #########
#########                             06/03/2017                                  #########
#########                              EMBL-EBI                                   #########
#########                           Thornton group                                #########
#########                                                                         #########
###########################################################################################
###########################################################################################
#####                                 cuRRBS paper                                     ####
###########################################################################################
##### Create a heatmap which represents the fragment length distributions generated by ####
##### the different isochizomer families of restriction enzymes. Moreover, create a    ####
##### scatterplot of median fragment length vs total number of fragments for each family. #
###########################################################################################
##### USAGE: manual                                                                    ####
###########################################################################################
#### Dependencies ####
library(circlize);
library(ComplexHeatmap);
library(ggplot2);
library(ggrepel);
#### Input arguments ####
setwd("~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/");
# Fragment length distributions input file (created with obtain_distributions_and_fragments_old.py).
fld_file_path <- "fl_distributions_1_enzymes.txt";
# Size ranges to test
min_size_range <- 1;
max_size_range <- 8001; # The last size range will include all fragments with length >= max_size_range
window_length <- 200;
#### Functions ####
## Function: given the fragment length distribution of a restriction enzyme and the size range of
#  interest, calculate the number of fragments in the given size range.
# fld: numeric matrix which contains the theoretical fragment length distribution.
#      First column: fragment length. Second column: number of fragments with that size.
# size_range: range of fragment lengths selected (e.g. 40_220). If NA, then the function returns NA.
NF_calculation <- function(fld, size_range){
if(is.na(size_range)){
return(NA);
}else{
min_size_f <- as.numeric(strsplit(size_range, '_')[[1]][1]);
max_size_f <- as.numeric(strsplit(size_range, '_')[[1]][2]);
selected_fragments <- fld[which(fld[,1] >= min_size_f & fld[,1] <= max_size_f),];
if(length(selected_fragments)>2){
NF <- sum(as.numeric(selected_fragments[,2]));
}
if(length(selected_fragments)==2){
NF <- as.numeric(selected_fragments[2]);
}
if(length(selected_fragments)<2){
NF <- 0;
}
return(NF);
}
}
#### Run the pipeline ####
### 1. Initialize important variables ###
print('Initializing variables ...');
## Create a vector with all the size ranges to test ##
lower_limits_vector <- seq(from=min_size_range, to=max_size_range, by=window_length);
if(lower_limits_vector[length(lower_limits_vector)] != max_size_range){
lower_limits_vector <- c(lower_limits_vector, max_size_range);
}
upper_limits_vector <- lower_limits_vector + window_length - 1;
upper_limits_vector[length(upper_limits_vector)] <- Inf;
size_ranges_vector <- rev(paste0(lower_limits_vector, '_', upper_limits_vector)); # Order from higher to lower
## Calculate the number of enzymes in the input file and other useful variables.
fld_headers <- system(paste0("grep -n '>' ", fld_file_path), intern=T);
n_enzymes <- length(fld_headers);
fld_chunk_sep <- as.numeric(sapply(strsplit(fld_headers, ':'), function(x){x[1]})); # Line numbers
fld_enz_combs <- sub('>', '', sapply(strsplit(fld_headers, ':'), function(x){x[2]})); # Enzyme names
## Final matrix to plot. Rows: enzymes. Columns: size ranges. Values: number of fragments for a given enzyme and size range.
final_NF_matrix <- matrix(NA, nrow=n_enzymes, ncol=length(size_ranges_vector));
rownames(final_NF_matrix) <- fld_enz_combs;
colnames(final_NF_matrix) <- gsub('_', '-', size_ranges_vector);
## Median fragment length for each enzyme.
median_fragment_length <- c();
### 2. Calculate the number of fragments for each one of the size ranges and each one of the enzymes ###
print('Calculating final matrix ...');
fld_file <- file(fld_file_path);
open(fld_file);
for(i in 1:length(fld_chunk_sep)){
# Read the fld chunk for the current enzyme
if(i == length(fld_chunk_sep)){ # For the last enzyme
current_fld <- readLines(fld_file, n=-1);
}else{
current_fld <- readLines(fld_file, n=fld_chunk_sep[i+1] - fld_chunk_sep[i]);
}
# Format the fld chunk of information.
current_fld <- current_fld[-1];
current_fld <- matrix(as.numeric(unlist(strsplit(current_fld, ','))), ncol=2, byrow=T);
# Calcualte the number of fragments for each size range.
final_NF_matrix[i,] <- sapply(size_ranges_vector, NF_calculation, fld=current_fld);
# Calculate the median fragment length for the current enzyme.
median_fragment_length <- c(median_fragment_length, median(rep(current_fld[,1], current_fld[,2])));
}
close(fld_file);
### 4. Generate a heatmap for the final matrix. Rows: size ranges. Columns: enzymes. Intensity: proportion of fragments (from the total) in the given size range and enzyme
print('Creating heatmap ...');
## Transform the matrix from absolute numbers to proportions of the total number of fragments per enzyme.
total_NF <- rowSums(final_NF_matrix);
proportions_matrix <- final_NF_matrix/total_NF;
proportions_matrix <- log(proportions_matrix,base = 10);
## Convert the -Inf values to NAs
proportions_matrix[which(proportions_matrix == "-Inf")] <- NA;
## Transpose the matrix to show the results in a gel-like way. i.e. rows: size ranges, columns: enzymes
pmt <- t(proportions_matrix);
View(proportions_matrix)
rownames(proportions_matrix)
motifs <- read.table("recognition_sites_enzymes.csv", header = F, sep = ",");
View(motifs)
rownames(proportions_matrix) == motifs$V1
all(rownames(proportions_matrix) == motifs$V1)
View(motifs)
if(!all(motifs[,1] == rownames(pmt))){
stop("Please, order the isoschizomer names correctly");
}
all(motifs[,1] == rownames(pmt))
motifs[,1]
as.character(motifs[,1])
all(as.character(motifs[,1]) == rownames(pmt))
rownames(pmt)
View(pmt)
###########################################################################################
#########                                                                         #########
#########                     Daniel Elias Martin Herranz                         #########
#########                             06/03/2017                                  #########
#########                              EMBL-EBI                                   #########
#########                           Thornton group                                #########
#########                                                                         #########
###########################################################################################
###########################################################################################
#####                                 cuRRBS paper                                     ####
###########################################################################################
##### Create a heatmap which represents the fragment length distributions generated by ####
##### the different isochizomer families of restriction enzymes. Moreover, create a    ####
##### scatterplot of median fragment length vs total number of fragments for each family. #
###########################################################################################
##### USAGE: manual                                                                    ####
###########################################################################################
#### Dependencies ####
library(circlize);
library(ComplexHeatmap);
library(ggplot2);
library(ggrepel);
#### Input arguments ####
setwd("~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/");
# Fragment length distributions input file (created with obtain_distributions_and_fragments_old.py).
fld_file_path <- "fl_distributions_1_enzymes.txt";
# Size ranges to test
min_size_range <- 1;
max_size_range <- 8001; # The last size range will include all fragments with length >= max_size_range
window_length <- 200;
#### Functions ####
## Function: given the fragment length distribution of a restriction enzyme and the size range of
#  interest, calculate the number of fragments in the given size range.
# fld: numeric matrix which contains the theoretical fragment length distribution.
#      First column: fragment length. Second column: number of fragments with that size.
# size_range: range of fragment lengths selected (e.g. 40_220). If NA, then the function returns NA.
NF_calculation <- function(fld, size_range){
if(is.na(size_range)){
return(NA);
}else{
min_size_f <- as.numeric(strsplit(size_range, '_')[[1]][1]);
max_size_f <- as.numeric(strsplit(size_range, '_')[[1]][2]);
selected_fragments <- fld[which(fld[,1] >= min_size_f & fld[,1] <= max_size_f),];
if(length(selected_fragments)>2){
NF <- sum(as.numeric(selected_fragments[,2]));
}
if(length(selected_fragments)==2){
NF <- as.numeric(selected_fragments[2]);
}
if(length(selected_fragments)<2){
NF <- 0;
}
return(NF);
}
}
#### Run the pipeline ####
### 1. Initialize important variables ###
print('Initializing variables ...');
## Create a vector with all the size ranges to test ##
lower_limits_vector <- seq(from=min_size_range, to=max_size_range, by=window_length);
if(lower_limits_vector[length(lower_limits_vector)] != max_size_range){
lower_limits_vector <- c(lower_limits_vector, max_size_range);
}
upper_limits_vector <- lower_limits_vector + window_length - 1;
upper_limits_vector[length(upper_limits_vector)] <- Inf;
size_ranges_vector <- rev(paste0(lower_limits_vector, '_', upper_limits_vector)); # Order from higher to lower
## Calculate the number of enzymes in the input file and other useful variables.
fld_headers <- system(paste0("grep -n '>' ", fld_file_path), intern=T);
n_enzymes <- length(fld_headers);
fld_chunk_sep <- as.numeric(sapply(strsplit(fld_headers, ':'), function(x){x[1]})); # Line numbers
fld_enz_combs <- sub('>', '', sapply(strsplit(fld_headers, ':'), function(x){x[2]})); # Enzyme names
## Final matrix to plot. Rows: enzymes. Columns: size ranges. Values: number of fragments for a given enzyme and size range.
final_NF_matrix <- matrix(NA, nrow=n_enzymes, ncol=length(size_ranges_vector));
rownames(final_NF_matrix) <- fld_enz_combs;
colnames(final_NF_matrix) <- gsub('_', '-', size_ranges_vector);
## Median fragment length for each enzyme.
median_fragment_length <- c();
### 2. Calculate the number of fragments for each one of the size ranges and each one of the enzymes ###
print('Calculating final matrix ...');
fld_file <- file(fld_file_path);
open(fld_file);
for(i in 1:length(fld_chunk_sep)){
# Read the fld chunk for the current enzyme
if(i == length(fld_chunk_sep)){ # For the last enzyme
current_fld <- readLines(fld_file, n=-1);
}else{
current_fld <- readLines(fld_file, n=fld_chunk_sep[i+1] - fld_chunk_sep[i]);
}
# Format the fld chunk of information.
current_fld <- current_fld[-1];
current_fld <- matrix(as.numeric(unlist(strsplit(current_fld, ','))), ncol=2, byrow=T);
# Calcualte the number of fragments for each size range.
final_NF_matrix[i,] <- sapply(size_ranges_vector, NF_calculation, fld=current_fld);
# Calculate the median fragment length for the current enzyme.
median_fragment_length <- c(median_fragment_length, median(rep(current_fld[,1], current_fld[,2])));
}
close(fld_file);
### 4. Generate a heatmap for the final matrix. Rows: size ranges. Columns: enzymes. Intensity: proportion of fragments (from the total) in the given size range and enzyme
print('Creating heatmap ...');
## Transform the matrix from absolute numbers to proportions of the total number of fragments per enzyme.
total_NF <- rowSums(final_NF_matrix);
proportions_matrix <- final_NF_matrix/total_NF;
proportions_matrix <- log(proportions_matrix,base = 10);
## Convert the -Inf values to NAs
proportions_matrix[which(proportions_matrix == "-Inf")] <- NA;
## Transpose the matrix to show the results in a gel-like way. i.e. rows: size ranges, columns: enzymes
pmt <- t(proportions_matrix);
rownames(pmt)
all(as.character(motifs[,1]) == colnames(pmt))
motifs <- read.table("recognition_sites_enzymes.csv", header = F, sep = ",");
all(as.character(motifs[,1]) == colnames(pmt))
if(!all(as.character(motifs[,1]) == colnames(pmt))){
stop("Please, order the isoschizomer names correctly");
}
motifs[,2]
?GC
library(seqinr);
numberAT <- sapply(as.character(motifs[,2]), GC, exact=TRUE);
as.character(motifs[,2])
motifs_seqs <- strsplit(as.character(motifs[,2]),"");
motifs_seqs
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT
GC_cont <- sapply(motifs_seqs, GC, exact=TRUE);
colorRamp2(c(floor(min(log_median_l)), ceiling(max(log_median_l))), c("white", "skyblue3"))
log_median_l <- log(median_fragment_length);
log_median_l
colorRamp2(c(floor(min(log_median_l)), ceiling(max(log_median_l))), c("white", "skyblue3"))
?colorRamp2
?HeatmapAnnotation
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2];
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3];
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4];
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5];
numberAT
gc_content <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2];
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3];
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4];
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5];
gc_cont <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT
source('~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/theoretical_fld_plots copy.R')
source('~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/theoretical_fld_plots copy.R')
lnt_col
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT[which(numberAT>=0 & numberAT<0.25)] <- brewer.pal(n=5, name = "YlGn")[2];
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- brewer.pal(n=5, name = "YlGn")[3];
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- brewer.pal(n=5, name = "YlGn")[4];
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- brewer.pal(n=5, name = "YlGn")[5];
numberAT
###########################################################################################
#########                                                                         #########
#########                     Daniel Elias Martin Herranz                         #########
#########                             06/03/2017                                  #########
#########                              EMBL-EBI                                   #########
#########                           Thornton group                                #########
#########                                                                         #########
###########################################################################################
###########################################################################################
#####                                 cuRRBS paper                                     ####
###########################################################################################
##### Create a heatmap which represents the fragment length distributions generated by ####
##### the different isochizomer families of restriction enzymes. Moreover, create a    ####
##### scatterplot of median fragment length vs total number of fragments for each family. #
###########################################################################################
##### USAGE: manual                                                                    ####
###########################################################################################
#### Dependencies ####
library(circlize);
library(ComplexHeatmap);
library(ggplot2);
library(ggrepel);
library(seqinr);
#### Input arguments ####
setwd("~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/");
# Fragment length distributions input file (created with obtain_distributions_and_fragments_old.py).
fld_file_path <- "fl_distributions_1_enzymes.txt";
# Size ranges to test
min_size_range <- 1;
max_size_range <- 8001; # The last size range will include all fragments with length >= max_size_range
window_length <- 200;
#### Functions ####
## Function: given the fragment length distribution of a restriction enzyme and the size range of
#  interest, calculate the number of fragments in the given size range.
# fld: numeric matrix which contains the theoretical fragment length distribution.
#      First column: fragment length. Second column: number of fragments with that size.
# size_range: range of fragment lengths selected (e.g. 40_220). If NA, then the function returns NA.
NF_calculation <- function(fld, size_range){
if(is.na(size_range)){
return(NA);
}else{
min_size_f <- as.numeric(strsplit(size_range, '_')[[1]][1]);
max_size_f <- as.numeric(strsplit(size_range, '_')[[1]][2]);
selected_fragments <- fld[which(fld[,1] >= min_size_f & fld[,1] <= max_size_f),];
if(length(selected_fragments)>2){
NF <- sum(as.numeric(selected_fragments[,2]));
}
if(length(selected_fragments)==2){
NF <- as.numeric(selected_fragments[2]);
}
if(length(selected_fragments)<2){
NF <- 0;
}
return(NF);
}
}
#### Run the pipeline ####
### 1. Initialize important variables ###
print('Initializing variables ...');
## Create a vector with all the size ranges to test ##
lower_limits_vector <- seq(from=min_size_range, to=max_size_range, by=window_length);
if(lower_limits_vector[length(lower_limits_vector)] != max_size_range){
lower_limits_vector <- c(lower_limits_vector, max_size_range);
}
upper_limits_vector <- lower_limits_vector + window_length - 1;
upper_limits_vector[length(upper_limits_vector)] <- Inf;
size_ranges_vector <- rev(paste0(lower_limits_vector, '_', upper_limits_vector)); # Order from higher to lower
## Calculate the number of enzymes in the input file and other useful variables.
fld_headers <- system(paste0("grep -n '>' ", fld_file_path), intern=T);
n_enzymes <- length(fld_headers);
fld_chunk_sep <- as.numeric(sapply(strsplit(fld_headers, ':'), function(x){x[1]})); # Line numbers
fld_enz_combs <- sub('>', '', sapply(strsplit(fld_headers, ':'), function(x){x[2]})); # Enzyme names
## Final matrix to plot. Rows: enzymes. Columns: size ranges. Values: number of fragments for a given enzyme and size range.
final_NF_matrix <- matrix(NA, nrow=n_enzymes, ncol=length(size_ranges_vector));
rownames(final_NF_matrix) <- fld_enz_combs;
colnames(final_NF_matrix) <- gsub('_', '-', size_ranges_vector);
## Median fragment length for each enzyme.
median_fragment_length <- c();
### 2. Calculate the number of fragments for each one of the size ranges and each one of the enzymes ###
print('Calculating final matrix ...');
fld_file <- file(fld_file_path);
open(fld_file);
for(i in 1:length(fld_chunk_sep)){
# Read the fld chunk for the current enzyme
if(i == length(fld_chunk_sep)){ # For the last enzyme
current_fld <- readLines(fld_file, n=-1);
}else{
current_fld <- readLines(fld_file, n=fld_chunk_sep[i+1] - fld_chunk_sep[i]);
}
# Format the fld chunk of information.
current_fld <- current_fld[-1];
current_fld <- matrix(as.numeric(unlist(strsplit(current_fld, ','))), ncol=2, byrow=T);
# Calcualte the number of fragments for each size range.
final_NF_matrix[i,] <- sapply(size_ranges_vector, NF_calculation, fld=current_fld);
# Calculate the median fragment length for the current enzyme.
median_fragment_length <- c(median_fragment_length, median(rep(current_fld[,1], current_fld[,2])));
}
close(fld_file);
### 4. Generate a heatmap for the final matrix. Rows: size ranges. Columns: enzymes. Intensity: proportion of fragments (from the total) in the given size range and enzyme
print('Creating heatmap ...');
## Transform the matrix from absolute numbers to proportions of the total number of fragments per enzyme.
total_NF <- rowSums(final_NF_matrix);
proportions_matrix <- final_NF_matrix/total_NF;
proportions_matrix <- log(proportions_matrix,base = 10);
## Convert the -Inf values to NAs
proportions_matrix[which(proportions_matrix == "-Inf")] <- NA;
## Transpose the matrix to show the results in a gel-like way. i.e. rows: size ranges, columns: enzymes
pmt <- t(proportions_matrix);
## Obtain the GC content for the motifs of the different enzymes
motifs <- read.table("recognition_sites_enzymes.csv", header = F, sep = ",");
if(!all(as.character(motifs[,1]) == colnames(pmt))){
stop("Please, order the isoschizomer names correctly");
}
motifs_seqs <- strsplit(as.character(motifs[,2]),"");
numberAT <- sapply(motifs_seqs, GC, exact=TRUE);
numberAT[which(numberAT>=0 & numberAT<0.25)] <- '0-25';
numberAT[which(numberAT>=0.25 & numberAT<0.5)] <- '25-50';
numberAT[which(numberAT>=0.5 & numberAT<0.75)] <- '50-75';
numberAT[which(numberAT>=0.75 & numberAT<=1)] <- '75-100';
numberAT
?brewer.pal
library(RColorBrewer);
gc_col <- c("0-25"=brewer.pal(n=5, name = "YlGn")[2],
"25-50"=brewer.pal(n=5, name = "YlGn")[3],
"50-75"=brewer.pal(n=5, name = "YlGn")[4],
"75-100"=brewer.pal(n=5, name = "YlGn")[5]);
source('~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/theoretical_fld_plots copy.R')
source('~/Desktop/methylation_clock/optimize_RRBS/cuRRBS_paper/Figure_1/Figure_1A/theoretical_fld_plots copy.R')
